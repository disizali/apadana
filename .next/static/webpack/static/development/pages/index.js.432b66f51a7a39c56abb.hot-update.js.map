{"version":3,"file":"static/webpack/static/development/pages/index.js.432b66f51a7a39c56abb.hot-update.js","sources":["webpack:///./src/earch.js"],"sourcesContent":["//(function(){\nvar AMOUNT = 200,\n  d = 25,\n  R = 200,\n  adjustment = true,\n  adaptive = true,\n  obliquity = (23 / 180) * 3.14,\n  roV1 = 0.0022,\n  roV2 = -0.0005,\n  ro1 = 0,\n  ro2 = 0,\n  canvas = \"#earth\",\n  color = \"#C0C0C0\",\n  fogC = \"#A9A9A9\",\n  T_earth = \"images/earth.png\";\n\nvar camera, scene, renderer;\n\nvar positions = [],\n  particles,\n  particle,\n  count = 0,\n  dpr,\n  lastW,\n  W = window.innerWidth,\n  H = window.innerHeight,\n  aspect = W / H,\n  vMin = Math.min(W, H);\n\nvar mouseX = 0,\n  mouseY = 0,\n  x0,\n  y0;\nvar lookAt = new THREE.Vector3(0, 0, 0),\n  canvas = document.querySelector(canvas);\n\nrenderer = new THREE.WebGLRenderer({\n  alpha: true,\n  antialias: true,\n  canvas: canvas\n}); //\nrenderer.setSize(W, H);\n//renderer.context.getExtension('OES_standard_derivatives');\ncamera = new THREE.PerspectiveCamera(18, aspect, 1, 10000);\nscene = new THREE.Scene();\nvar Emap = new THREE.TextureLoader().load(T_earth);\nEmap.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy()) || 1;\nvar Wmaterial = new THREE.MeshStandardMaterial({\n  onBeforeCompile: function(sh) {\n    sh.vertexShader =\n      \"\\\n#define MYSHADER\\n\\\nattribute float center, bright;\\n\\\nvarying vec3 vCenter, vPos, vV0, vV1, vV2;\\n\\\nvarying float vBright;\\n\\\n\" +\n      sh.vertexShader.replace(\n        /}\\s*$/,\n        \"\\\nvBright=bright;\\n\\\nint c=int(center);\\n\\\nvCenter = vec3(c==0, c==1, c==2);\\n\\\nvPos=position;\\n\\\ngl_Position = projectionMatrix * modelViewMatrix * vec4(vPos, 1);\\n\\\nvV0=vCenter[0]*vPos;\\n\\\nvV1=vCenter[1]*vPos;\\n\\\nvV2=vCenter[2]*vPos;\\n\\\n}\t\t\t\"\n      );\n    sh.fragmentShader =\n      \"\\\n#define MYSHADER\\n\\\nvarying vec3 vCenter, vPos, vV0, vV1, vV2;\\n\\\nvarying float vBright;\\n\\\n\" +\n      sh.fragmentShader\n        .replace(\n          \"#include <alphamap_fragment>\",\n          \"\\\n#include <alphamap_fragment>\\n\\\nvec3 d = fwidth( vCenter );\\n\\\nvec3 a3 = smoothstep( vec3(0.0), d * 1.4, vCenter+0.4*d-1.0/fogDepth );\\n\\\nfloat scale = dot(normalize(vViewPosition), vNormal);\\n\\\nscale = 1.0-scale*scale;\\n\\\nfloat dist = distance(vPos, vV0.xyz/vCenter.x);\\n\\\ndist = min(dist, distance(vPos, vV1.xyz/vCenter.y));\\n\\\ndist = min(dist, distance(vPos, vV2.xyz/vCenter.z));\\n\\\nfloat b3 = smoothstep(1.5, 1.8, dist-1.5*scale*scale );\\n\\\nfloat edgeFactorTri=min(b3,min( min( a3.x, a3.y ), a3.z ));\\n\\\ndiffuseColor.a *= mix( 1.0,  0.0, edgeFactorTri );\\n\\\nfloat dissipation=\" +\n            (posZ + 0.5 * R + 0.01) +\n            \";\\n\\\ndiffuseColor.a *= smoothstep( 20.0,  0.0, fogDepth-dissipation );\\n\\\n\t\t\t\"\n        )\n        .replace(\n          \"\t#include <fog_fragment>\",\n          \"\\\nfloat lVc=length(vCenter);\\n\\\ngl_FragColor.rgb *= smoothstep( \" +\n            R * 0.8888 +\n            \", \" +\n            R * 1.201 +\n            \", fogDepth );\\n\\\ngl_FragColor.rgb = mix( gl_FragColor.rgb, vec3(3), (.1*lVc+pow(lVc,8.0))*vBright );\\n\\\n#include <fog_fragment>\\\n\t\t\t\"\n        );\n    //console.log(sh, sh.vertexShader, sh.fragmentShader);\n  },\n  roughness: 0.5,\n  metalness: 0.964,\n  envMapIntensity: 5,\n  emissive: 0,\n  // refractionRatio: -0.12,\n  transparent: true,\n  alphaTest: 0.05\n}); //, opacity: 0\nWmaterial.color.set(fogC);\nWmaterial.side = 2;\nWmaterial.extensions = { derivatives: 1 };\nvar geometry = new THREE.IcosahedronGeometry(R, 3); //OctahedronGeometry\n\nfor (var i = 0; i < geometry.vertices.length; i++) {\n  geometry.vertices[i].applyEuler(\n    new THREE.Euler(\n      Math.random() * 0.06,\n      Math.random() * 0.06,\n      Math.random() * 0.06\n    )\n  );\n}\nvar bGeometry = new THREE.BufferGeometry().fromGeometry(geometry);\nvar position = bGeometry.attributes.position;\nvar centers = new Int8Array(position.count);\nvar brights = new Float32Array(position.count);\nvar points = [],\n  activePoints = [],\n  vCount = geometry.vertices.length,\n  dCount = 0,\n  dMid = 0;\n\nfor (var i = 0, l = position.count; i < l; i++) {\n  var c = (centers[i] = i % 3),\n    j = (i - c) / 3;\n  brights[i] = 0;\n  if (i < vCount)\n    points[i] = {\n      siblings: [],\n      distances: [],\n      indexes: [],\n      brightness: 0,\n      v: 0,\n      a: 0,\n      f: 0,\n      dr: 0,\n      r: 1\n    };\n}\nfunction addSiblings(a, b, one) {\n  if (points[a].siblings.indexOf(points[b]) < 0) {\n    points[a].pos = geometry.vertices[a].clone();\n    points[a].siblings.push(points[b]);\n    var d = geometry.vertices[a].distanceTo(geometry.vertices[b]);\n    points[a].distances.push(d);\n    dMid += d;\n    dCount++;\n  }\n  if (!one) addSiblings(b, a, 1);\n}\ngeometry.faces.forEach(function(face, i) {\n  addSiblings(face.a, face.b);\n  addSiblings(face.a, face.c);\n  addSiblings(face.c, face.b);\n  points[face.a].indexes.push(i * 3);\n  points[face.b].indexes.push(i * 3 + 1);\n  points[face.c].indexes.push(i * 3 + 2);\n});\ndMid /= dCount;\nvar ttl = 10;\n(function setActive(n) {\n  if (!n) return;\n  var i = parseInt(Math.random() * vCount);\n  if (geometry.vertices[i].z < -100) setActive();\n  else (points[i].isActive = ttl), activePoints.push(points[i]);\n  setActive(n - 1);\n})(10);\n\nbGeometry.addAttribute(\"center\", new THREE.BufferAttribute(centers, 1));\nbGeometry.addAttribute(\"bright\", new THREE.BufferAttribute(brights, 1));\n\nvar Ematerial = Wmaterial.clone();\nEmaterial.alphaMap = Emap;\nEmaterial.transparent = false;\nEmaterial.side = 0;\nvar cubeCamera = new THREE.CubeCamera(1, 2 * R, 256);\ncubeCamera.position.z = 0.47 * R;\nEmaterial.envMap = cubeCamera.renderTarget.texture;\nEmaterial.envMap.minFilter = THREE.LinearMipMapLinearFilter;\nEmaterial.envMap.mapping = THREE.CubeReflectionMapping;\nvar Earth = new THREE.Mesh(\n  new THREE.IcosahedronGeometry(R * 0.77, 3),\n  Ematerial\n);\nvar wGeometry = geometry.clone();\nparticles = new THREE.Group();\nlet world = new THREE.Group();\nvar Net = new THREE.Mesh(bGeometry, Wmaterial);\nparticles.add(Net, Earth); //new THREE.Points(geometry, Pmaterial),\n//particles.rotation.order='YXZ'\nworld.add(particles);\nscene.add(world);\n// POSITIONS :\nvar posZ = 1700; //distance to camera\n//scene.position.set(-12,54,0);\n\n//camera.position.y=camera.position.z=2000\n\nscene.fog = new THREE.Fog(fogC, posZ - R / 2, posZ + R);\nlet hLight = new THREE.HemisphereLight(\"#fff\", 0, 23);\nworld.add(hLight);\nhLight.position.set(0, 0, 1);\n\n// interactions\nvar dx,\n  dy = (dx = x0 = y0 = 0),\n  active,\n  abc = [\"a\", \"b\", \"c\"],\n  movedPoints = [],\n  activeF = [],\n  ready,\n  raycaster = new THREE.Raycaster(),\n  mouse = new THREE.Vector2();\nwindow.getWpos = function() {\n  return [scene.position, scene.rotation, camera];\n};\nfunction interact() {\n  mouse.x = (x0 / W) * 2 - 1;\n  mouse.y = -(y0 / H) * 2 + 1;\n  raycaster.setFromCamera(mouse, camera);\n  movedPoints.forEach(function(point, i) {\n    point.f = 0;\n  });\n  activeF = [];\n  if (!active) return;\n  var inters = raycaster.intersectObject(Net)[0],\n    ind,\n    vert;\n  if (!inters) return;\n  point = Net.worldToLocal(inters.point.clone());\n  for (var i = 0; i < 3; i++) {\n    ind = inters.face[abc[i]];\n    if (\n      !points.some(function(p, i) {\n        return p.indexes.indexOf(ind) >= 0 && (vert = i + \"\");\n      })\n    )\n      return;\n    activeF[vert] =\n      Math.max(1 - point.distanceTo(points[vert].pos) / dMid, 0) * 100;\n  }\n  // console.log(activeF, points[vert]);\n}\ncanvas.onpointerdown = canvas.onmousedown = canvas.ontouchstart = function(e) {\n  active = e.changedTouches ? e.changedTouches[0] : e;\n  x0 = active.clientX;\n  y0 = active.clientY;\n  e.preventDefault();\n  interact();\n};\nlet onpointermove = (onmousemove = ontouchmove = function(e) {\n  if (!active || !ready) return;\n  if (!e.buttons) {\n    active = false;\n    return;\n  }\n  var touches = e.changedTouches;\n  if (active.identifier !== undefined && e.type != \"touchmove\") return;\n  if (touches) {\n    if (touches[0].identifier == active.identifier) e = touches[0];\n    else return;\n  } else {\n    e.preventDefault();\n  }\n  //if (e.type==mousemove && !e.which) return\n  dx = (5 * dx + x0 - (x0 = e.clientX)) / 6;\n  dy = (5 * dy + y0 - (y0 = e.clientY)) / 6;\n  //console.log(e.type, active.identifier, dx, x0)\n  interact();\n  ready = 0;\n});\nonmouseup = onpointerup = ontouchup = ontouchcancel = onpointercancel = onblur = function(\n  e\n) {\n  active = false;\n  //console.log()\n  interact();\n};\n\nvar t0 = new Date() * 1,\n  dMax = 80,\n  dMin = 1000 / 33,\n  dT = 1000 / 50,\n  af,\n  Pactive = [],\n  m = 3000000,\n  k = 400,\n  k0 = 1,\n  f0 = 0.01,\n  fv = 1000,\n  posArr = bGeometry.attributes.position.array,\n  pUp = 0,\n  pDn = [],\n  flTimer = [],\n  vecTest = new THREE.Vector3(),\n  transStart,\n  pLast,\n  transactions = [];\nrequestAnimationFrame(function animate() {\n  requestAnimationFrame(animate);\n  var t = new Date() * 1,\n    dt = t - t0;\n  if (dt < dMin) return; // !Eh ||\n  dt = Math.min(dt, dMax);\n  t0 = t;\n  var dd = dt / dT;\n  var pos = canvas.getBoundingClientRect(),\n    dY =\n      window.innerHeight -\n      document.documentElement.getBoundingClientRect().bottom;\n  if (pos.bottom <= 0 || pos.top >= window.innerHeight) return;\n  if (\n    dpr != (dpr = window.devicePixelRatio) ||\n    W != (W = window.innerWidth) ||\n    H != (H = window.innerHeight)\n  ) {\n    vMin = Math.min(W, H);\n    renderer.setSize(W, H);\n    renderer.setPixelRatio(dpr);\n    camera.aspect = W / H;\n    camera.updateProjectionMatrix();\n  }\n  var addPoints = [];\n  activePoints.forEach(function(point, i) {\n    var b = point.brightness;\n    if (point.isActive && (b += (point.speed || 0.3) * (b + 0.05) * dd) > 1) {\n      //\n      point.siblings.forEach(function(s, j) {\n        if (activePoints.indexOf(s) > -1) return; //console.log(11);\n        s.speed = 3.7 / point.distances[j];\n        //s.from=point;\n        if ((s.isActive = Math.random() > 0.6)) activePoints.push(s);\n      });\n      point.isActive = 0;\n    } else if (!point.isActive && (b -= b * 0.056 * dd) < 0.005) {\n      b = 0; //point.from=\n      activePoints.splice(i, 1);\n    }\n    point.brightness = b;\n    point.indexes.forEach(function(i) {\n      brights[i] = b;\n    });\n  });\n  points.forEach(function(point, i) {\n    var d = 0;\n    point.siblings.forEach(function(s, j) {\n      d += s.dr;\n    });\n    d = d / point.siblings.length - point.dr;\n    point.f =\n      -(activeF[i] || 0) * 0.4 +\n      d * k -\n      point.dr * k0 * (1 + Math.abs(1 - point.r)) -\n      point.v * fv;\n    point.v += (point.f * dt) / m;\n    point.r = 1 + point.dr;\n    point.indexes.forEach(function(j) {\n      //brights[i]+=point.f; return;\n      posArr[(j *= 3)] = point.r * point.pos.x;\n      posArr[j + 1] = point.r * point.pos.y;\n      posArr[j + 2] = point.r * point.pos.z;\n    });\n  });\n  points.forEach(function(point, i) {\n    if (!point.v) return;\n    var dd = point.v * dt;\n    point.dr += dd;\n  });\n  bGeometry.attributes.bright.needsUpdate = true;\n  bGeometry.attributes.position.needsUpdate = true;\n  camera.position.z += (posZ - camera.position.z) * 0.085 * dd;\n  ro1 += roV1 * dd;\n  ro2 += roV2 * dd;\n  particles.rotation.set(0, 0, 0);\n  particles\n    .rotateY(ro2)\n    .rotateX(obliquity)\n    .rotateY(ro1);\n  particles.rotation.y -= 0.0009;\n\n  dx *= 1 - 0.03 * dd;\n  dy *= 1 - 0.03 * dd;\n  ro2 -= dx * 0.002; //+(W/2-y0)*(W/2-x0)*dy/vMin*.00004;\n  world.rotation.x -= dy * 0.002;\n  var sro = (world.rotation.x *= 0.92);\n  Net.applyMatrix(\n    new THREE.Matrix4()\n      .getInverse(particles.matrixWorld)\n      .multiply(\n        new THREE.Matrix4().makeRotationFromEuler(\n          new THREE.Euler(-dy * 0.003, -dx * 0.002, 0)\n        )\n      )\n      .multiply(particles.matrixWorld) //new THREE.Matrix4()\n  );\n  Earth.visible = !1;\n  scene.scale.set(0.33, 0.33, 0.65); //.applyEuler(new THREE.Euler(-sro,0,0))\n  cubeCamera.update(renderer, scene);\n  Earth.visible = !0;\n  scene.scale.set(1, 1, 1);\n  particles.matrixWorldNeedsUpdate = true;\n  renderer.render(scene, camera);\n  ready = 1;\n});\n//})()\n"],"mappings":";;;;;;;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AAAA;AAIA;AAAA;AAGA;AACA;AACA;AACA;AAHA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AACA;;;;;;;;;AAMA;AAaA;;;;AACA;;;;;;;;;;;;AAQA;;AAHA;;AAuBA;;;AAvBA;AAmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtEA;AACA;AAuEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAOA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAQA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAUA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}